package com.alysoft.algo.bits;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.ArrayList;
import java.util.Hashtable;
import java.util.Iterator;

/**
 * Given an array arr[] of N positive elements. The task is to find the Maximum AND Value generated by any pair of element from the array.
Note: AND is bitwise '&' operator.

Input:
The first line of the input contains a single integer T, denoting the number of test cases. Then T test cases follow. 
Each test-case has two lines of the input, the first line contains an integer denoting the size of an array N and the second 
line of input contains N positive integers

Output:
For each testcase, print Maximum AND Value of a pair in a separate line.

User Task:
The task is to complete the function maxAND() which takes the array elements and N (size of array) and input and returns the 
maximum AND value generated by any pair in the array.

Constraints:
1 <=T <= 100
1 <= N <= 100
1 <= arr[i] <= 104

Example:
Input:
2
4
4 8 12 16
4
4 8 16 2

Output:
8
0

Explanation:
Testcase 1: Pair (8,12) has the Maximum AND Value  i.e. 8.
Testcase 2: Maximum AND Value is 0.
 * @author ymohammad
 *
 */
public class MaximumANDValue
{

	public static void main1(String[] args)
	{
		int[] arr = {4, 8, 16, 2};
		System.out.println(maxAND(arr, arr.length));
	}
	public static void main (String[] args) throws IOException {
		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
		int t = Integer.parseInt(br.readLine().trim()); //Inputting the testcases
		while(t-->0){
		    int n = Integer.parseInt(br.readLine());
		    String inputLine[] = br.readLine().trim().split(" ");
		    int arr[] = new int[n];
		    for(int i=0; i<n; i++){
		        arr[i]=Integer.parseInt(inputLine[i]);
		    }
		    
		    
		    System.out.println(maxAND(arr, n));
		}
	}
	public static int maxAND (int arr[], int n) {
        
        // Your code here
        // You can add extra function (if required)
        Hashtable<Integer, ArrayList<Integer>> hash = new Hashtable<Integer, ArrayList<Integer>>();
        for (int x: arr) {
            int msdPosition = log(x, 2);
            if (hash.containsKey(msdPosition)) {
            	hash.get(msdPosition).add(x);
            } else {
            	ArrayList<Integer> list = new ArrayList<Integer>();
            	list.add(x);
            	hash.put(msdPosition, list);
            }
        }
        Iterator<Integer> iterator = hash.keySet().iterator();
        int result = 0;
        while (iterator.hasNext()) {
        	int key = iterator.next();
        	ArrayList<Integer> arrayList = hash.get(key);
            if (arrayList.size() > 1) {
            	result |= (1 << key);
            }
        }
        
        return result;
    }
    public static int log(int x, int b)
	{
	    return (int) (Math.log(x) / Math.log(b));
	}
}
